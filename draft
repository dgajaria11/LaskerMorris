import random
import time

# Board configuration: list of points where the stones can be placed
valid_points = [
    'a1', 'a3', 'a5', 'b2', 'b4', 'b6', 'c1', 'c3', 'c5', 'd2', 'd4', 'd6',
    'e1', 'e3', 'e5', 'f2', 'f4', 'f6', 'g1', 'g3', 'g5'
]

# Initialize the board (Empty board)
board = {point: None for point in valid_points}

# Player colors
BLUE = "blue"
ORANGE = "orange"

# Game state tracking
player_hand = {BLUE: 10, ORANGE: 10}  # 10 pieces for each player at the start

# Function to check if a player has only 2 stones left
def has_two_stones_left(player):
    return player_hand[player] == 2

# Function to check if a player has only 3 stones left (flying rule)
def has_three_stones_left(player):
    return player_hand[player] == 3

# Function to check if a player has formed a mill
def check_mill(board, player):
    mills = [
        ['a1', 'a3', 'a5'],
        ['b2', 'd4', 'f6'],
        ['c1', 'c3', 'c5'],
        ['b4', 'd2', 'f4'],
        ['e1', 'e3', 'e5'],
        ['c1', 'd4', 'f6']
    ]
    
    for mill in mills:
        if all(board[point] == player for point in mill):
            return mill  # Return the positions of the formed mill
    return None

# Function to remove an opponent's stone (Player Chooses)
def remove_opponent_stone(board, player):
    opponent = BLUE if player == ORANGE else ORANGE
    
    # Get the opponent's stones
    opponent_stones = [point for point, color in board.items() if color == opponent]
    valid_stones_to_remove = []
    
    # Check if the opponent's stones are part of a mill
    for stone in opponent_stones:
        mill_positions = check_mill(board, opponent)
        if not mill_positions:  # If the opponent doesn't have any mills, remove any stone
            valid_stones_to_remove.append(stone)
        elif stone not in mill_positions:  # Only remove stones not in mills
            valid_stones_to_remove.append(stone)

    if valid_stones_to_remove:
        # Prompt the player to pick which stone to remove
        print(f"Choose an opponent's stone to remove from: {valid_stones_to_remove}")
        stone_to_remove = input(f"Enter the position (e.g., {valid_stones_to_remove[0]}): ").strip()
        
        # Validate the player input
        if stone_to_remove in valid_stones_to_remove:
            board[stone_to_remove] = None
            print(f"Removed opponent's stone from {stone_to_remove}")
        else:
            print("Invalid selection. No stone was removed.")
    else:
        print("No valid stones to remove.")

# Function to check if the game has ended
def check_game_end():
    if has_two_stones_left(BLUE):
        print("Player BLUE has only 2 stones left! Player ORANGE wins!")
        return True
    elif has_two_stones_left(ORANGE):
        print("Player ORANGE has only 2 stones left! Player BLUE wins!")
        return True
    return False

# Function to check if a move is adjacent (used for normal moves)
def is_adjacent(source, destination):
    adjacency = {
        'a1': ['a3', 'b2'],
        'a3': ['a1', 'a5', 'b2'],
        'a5': ['a3', 'b4'],
        'b2': ['a1', 'a3', 'd4'],
        'b4': ['a5', 'd2', 'f6'],
        'b6': ['c5', 'd4'],
        'c1': ['c3', 'd2'],
        'c3': ['a3', 'c1', 'e1'],
        'c5': ['b4', 'e5'],
        'd2': ['b2', 'c3', 'e3'],
        'd4': ['b4', 'd2', 'f4'],
        'd6': ['f4', 'f6'],
        'e1': ['c3', 'e3'],
        'e3': ['d2', 'e1', 'f2'],
        'e5': ['c5', 'f6'],
        'f2': ['e3', 'f4'],
        'f4': ['d4', 'e5', 'f2'],
        'f6': ['b6', 'e5', 'd6'],
        'g1': ['g3'],
        'g3': ['g1', 'g5'],
        'g5': ['g3']
    }
    return destination in adjacency.get(source, [])

# Function to make a move and check if the game ends
def make_move(board, move, player):
    source, destination, remove = move.split()
    source = source.strip()
    destination = destination.strip()
    remove = remove.strip()
    
    # If the player has only 3 stones left, they can "fly" to any empty spot
    if has_three_stones_left(player):
        # No adjacency requirement for flying move
        if board[destination] is None:  # The destination must be empty
            board[destination] = player
            print(f"Player {player} flew a stone to {destination}")
        else:
            print(f"Invalid move: {destination} is already occupied.")
            return
    else:
        # Normal move with adjacency rule (if the stone is not from the hand)
        if source == "h1" or source == "h2":  # If the stone is coming from the player's hand
            board[destination] = player
        else:
            # If moving a stone, ensure it's adjacent unless flying
            if is_adjacent(source, destination):
                board[destination] = player
            else:
                print(f"Invalid move: {destination} is not adjacent to {source}.")
                return

    print(f"Player {player} moved: {source} -> {destination}")
    
    # Check if a mill was formed and remove opponent's stone
    if check_mill(board, player):
        remove_opponent_stone(board, player)
    
    # After each move, check if the game should end
    if check_game_end():
        return True
    return False

# Function to choose the best move using minimax
def choose_move(board, player, depth=3):
    best_move = None
    best_value = float('-inf') if player == BLUE else float('inf')
    
    valid_moves = [point for point, value in board.items() if value is None]
    
    for move in valid_moves:
        board[move] = player
        move_value = minimax(board, depth - 1, float('-inf'), float('inf'), player == ORANGE, player)
        if (player == BLUE and move_value > best_value) or (player == ORANGE and move_value < best_value):
            best_value = move_value
            best_move = move
        board[move] = None  # Undo the move
    
    return best_move

# Main game loop with updated end conditions
def play_game():
    current_player = BLUE
    while True:
        # Wait for opponent's move
        move = input().strip()
        
        # Parse move (e.g., 'h1 d1 r0')
        move_parts = move.split()
        
        if move_parts[0] == current_player:
            print(f"Player {current_player} makes move: {move_parts}")
            if move_parts[2] != "r0":
                print("Invalid move: Opponent made an illegal move")
                break  # Handle invalid moves
                
            # Calculate best move for the current player
            best_move = choose_move(board, current_player)
            print(best_move)
            
            # Send the best move to referee
            if make_move(board, best_move, current_player):
                break  # Game ends if the player has 2 stones left
                
            current_player = BLUE if current_player == ORANGE else ORANGE  # Switch player

if __name__ == "__main__":
    play_game()
